# Digital Ocean

1. Create new project
2. Manage > Droplets
3. Create Droplet
    - Region: New York
    - Datacenter: New York Data Center 1 NYC1
    - OS: Ubuntu
    - Version: 24.04 (LTS) x64
    - Size: Basic
    - CPU Options: Regular Disk type: ssd
    - $4 a month
    - Authentication method: SSH Key
        - Run ssh-keygen on local machine
        - This will generate two files, by default called id_rsa and id_rsa.pub. Next, add this public key.
        - Copy and paste the contents of the .pub file, typically id_rsa.pub, into the SSH key content field on the left.: cat ~/.ssh/id_rsa.pub
    - Quantity: 1 Droplet
    - Project: react-blog
    

1. ssh into digital ocean droplet: `ssh root@<ipv4>`
2. `sudo apt update`
3. `sudo apt -y upgrade`
4. `sudo apt install nodejs npm`
5. confirm node and npm was installed correctly:
    - `node -v`
    - `npm -v`

6. `git clone https://github.com/loganphillips792/react-flask-custom-blog.git`
7. `cd react-flask-custom-blog/frontend/react-flask-custom-blog`
8. `npm install`
9. `npm run build` - prepare app for production. This creates a build/ directory with the production-ready files
	- If the command fails with `Killed`, then the issue is probably no swap memory available
	- `sudo free -h` to check if there is any swap memory available. If 0, then that is the issue
	- Add swap memory
		1. sudo fallocate -l 1G /swapfile
		2. ls -lh /swapfile to verify
		3. sudo chmod 600 /swapfile
		4. ls -lh /swapfile to verify
		5. sudo mkswap /swapfile to mark the file as swap space
		6. sudo swapon /swapfile to enable it
		7. sudo swapon --show to verify that the swap is available
		8. free -h to verify again
		9. Our recent changes have enabled the swap file for the current session. However, if we reboot, the server will not retain the swap settings automatically. We can change this by adding the swap file to our /etc/fstab file
			1. sudo cp /etc/fstab /etc/fstab.bak to back up the /etc/fstab file just incase
			2. echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab add the swap file information
		10. `npm run build` should work now

10. npm install -g serve
11. serve -s dist (this should only be used for testing)
12. Now you should be able to access at: ipv4@:3000


## Nginx - Reverse Proxy

so we don't have to include the port and it is mapped to port 80

sudo apt install nginx

sudo vim /etc/nginx/sites-available/default

```
##
# You should look at the following URL's in order to grasp a solid understanding
# of Nginx configuration files in order to fully unleash the power of Nginx.
# https://www.nginx.com/resources/wiki/start/
# https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/
# https://wiki.debian.org/Nginx/DirectoryStructure
#
# In most cases, administrators will remove this file from sites-enabled/ and
# leave it as reference inside of sites-available where it will continue to be
# updated by the nginx packaging team.
#
# This file will automatically load configuration files provided by other
# applications, such as Drupal or Wordpress. These applications will be made
# available underneath a path with that package name, such as /drupal8.
#
# Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.
##

# Default server configuration
#
server {
	listen 80 default_server;
	listen [::]:80 default_server;

	# SSL configuration
	#
	# listen 443 ssl default_server;
	# listen [::]:443 ssl default_server;
	#
	# Note: You should disable gzip for SSL traffic.
	# See: https://bugs.debian.org/773332
	#
	# Read up on ssl_ciphers to ensure a secure configuration.
	# See: https://bugs.debian.org/765782
	#
	# Self signed certs generated by the ssl-cert package
	# Don't use them in a production server!
	#
	# include snippets/snakeoil.conf;

	root /var/www/html;

	# Add index.php to the list if you are using PHP
	index index.html index.htm index.nginx-debian.html;

	server_name _;

	location / {
		# First attempt to serve request as file, then
		# as directory, then fall back to displaying a 404.
		try_files $uri $uri/ =404;
	}

	# pass PHP scripts to FastCGI server
	#
	#location ~ \.php$ {
	#	include snippets/fastcgi-php.conf;
	#
	#	# With php-fpm (or other unix sockets):
	#	fastcgi_pass unix:/run/php/php7.4-fpm.sock;
	#	# With php-cgi (or other tcp sockets):
	#	fastcgi_pass 127.0.0.1:9000;
	#}

	# deny access to .htaccess files, if Apache's document root
	# concurs with nginx's one
	#
	#location ~ /\.ht {
	#	deny all;
	#}
}


# Virtual Host configuration for example.com
#
# You can move that to a different file under sites-available/ and symlink that
# to sites-enabled/ to enable it.
#
#server {
#	listen 80;
#	listen [::]:80;
#
#	server_name example.com;
#
#	root /var/www/example.com;
#	index index.html;
#
#	location / {
#		try_files $uri $uri/ =404;
#	}
#}


server {
    listen 80;
    server_name <ipv4_of_droplet>;

    location / {
        proxy_pass http://localhost:3000;  # Assuming serve runs on port 3000
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}

```

sudo systemctl restart nginx.service


Run `serve -s dist`(if not already running via `pm2`) and now you should be able to access at `ipv4@:80` instead of `ipv4@:3000`

To further test:
`sudo systemctl stop nginx.service` and `ipv4@:80` should fail
`sudo systemctl start nginx.service` and `ipv4@:80` should work again


## SSL Certificate Setup








## PM2

Now we will use PM2 to run serve -s dist as a background process


1. npm install -g pm2
2. `pm2 start serve --name "react-app" -- -s dist` will cause an error. You have to do `pm2 start "npx serve -s dist" --name react-app`
3. pm2 startup - Ensure the process starts on reboot: To make sure the app starts when the server reboots, you need to set up pm2 to run at startup
4. pm2 save - Save the process list: After setting up the startup script, save the current running processes to be restored automatically on reboot
5. `<ipv4>:3000/all-blog-posts` in your browser to test
6. pm2 stop react-app and `<ipv4>:3000` and note that it breaks
7. pm2 start react-app and `<ipv4>:3000` and note that it works again

- pm2 list - check running apps
- pm2 logs react-app - view logs
- pm2 stop react-app
- pm2 restart react-app
- pm2 delete react-app

## systemd service

Alternatively, you can create a systemd service to run serve -s build as a background process. This method is more integrated with Linux systems and also ensures that the process runs on system boot.



1. Create a new systemd service file: Create a service file for your app by running: sudo nano /etc/systemd/system/react-app.service


2. Define the service configuration: Paste the following configuration into the file:

```
[Unit]
Description=React App
After=network.target

[Service]
ExecStart=/usr/bin/serve -s /path/to/your/react/app/build
Restart=always
User=root
Environment=PATH=/usr/bin:/usr/local/bin
Environment=NODE_ENV=production
WorkingDirectory=/path/to/your/react/app

[Install]
WantedBy=multi-user.target
```

3. sudo systemctl daemon-reload

4. sudo systemctl start react-app

5. sudo systemctl enable react-app

6. sudo systemctl status react-app

7. journalctl -u react-app -f

## Nginx - serve static files

Using Nginx as a web server

`vim /etc/nginx/sites-available/default`

```
##
# You should look at the following URL's in order to grasp a solid understanding
# of Nginx configuration files in order to fully unleash the power of Nginx.
# https://www.nginx.com/resources/wiki/start/
# https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/
# https://wiki.debian.org/Nginx/DirectoryStructure
#
# In most cases, administrators will remove this file from sites-enabled/ and
# leave it as reference inside of sites-available where it will continue to be
# updated by the nginx packaging team.
#
# This file will automatically load configuration files provided by other
# applications, such as Drupal or Wordpress. These applications will be made
# available underneath a path with that package name, such as /drupal8.
#
# Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.
##

# Default server configuration
#
server {
	listen 80 default_server;
	listen [::]:80 default_server;

	# SSL configuration
	#
	# listen 443 ssl default_server;
	# listen [::]:443 ssl default_server;
	#
	# Note: You should disable gzip for SSL traffic.
	# See: https://bugs.debian.org/773332
	#
	# Read up on ssl_ciphers to ensure a secure configuration.
	# See: https://bugs.debian.org/765782
	#
	# Self signed certs generated by the ssl-cert package
	# Don't use them in a production server!
	#
	# include snippets/snakeoil.conf;

	root /var/www/html;

	# Add index.php to the list if you are using PHP
	index index.html index.htm index.nginx-debian.html;

	server_name _;

	location / {
		# First attempt to serve request as file, then
		# as directory, then fall back to displaying a 404.
		try_files $uri $uri/ =404;
	}

	# pass PHP scripts to FastCGI server
	#
	#location ~ \.php$ {
	#	include snippets/fastcgi-php.conf;
	#
	#	# With php-fpm (or other unix sockets):
	#	fastcgi_pass unix:/run/php/php7.4-fpm.sock;
	#	# With php-cgi (or other tcp sockets):
	#	fastcgi_pass 127.0.0.1:9000;
	#}

	# deny access to .htaccess files, if Apache's document root
	# concurs with nginx's one
	#
	#location ~ /\.ht {
	#	deny all;
	#}
}


# Virtual Host configuration for example.com
#
# You can move that to a different file under sites-available/ and symlink that
# to sites-enabled/ to enable it.
#
#server {
#	listen 80;
#	listen [::]:80;
#
#	server_name example.com;
#
#	root /var/www/example.com;
#	index index.html;
#
#	location / {
#		try_files $uri $uri/ =404;
#	}
#}

server {
    listen 80;
    server_name 157.230.5.245;

    # Serve the React app from the build folder
    root /var/www/react-app/;
    index index.html;

    # Main location block for the React app
    location / {
        try_files $uri /index.html;
    }
}
```

if you go to ipv4:80, you will see the Nginx set up page

Can now access files like http://157.230.5.245/vite.svg

## Netlify


Base directory: frontend/react-flask-custom-blog
Package directory: not set
Build command: npm run build
publish directory: frontend/react-flask-custom-blog/dist

# Flask Setup

SSH into digital ocean droplet: `ssh root@<ipv4_of_droplet>`

cat /var/log/nginx/access.log
cat /var/log/nginx/error.log


1. sudo apt update
2. sudo apt -y upgrade
3. apt install python3.12-venv
4. cd ~
5. sudo python3 -m venv blog-venv
6. source ~/blog-venv/bin/activate
7. which pip
8. ~/blog-venv/bin/python3 -m pip install --upgrade pip
9. pip install -r react-flask-custom-blog/backend/requirements.txt
10. cp .env.example .env
11. python app.py to make sure there aren't any errors


cd ~/react-flask-custom-blog/backend

gunicorn --workers 3 --bind 0.0.0.0:5000 -m 007 app:app

curl request to test: `curl <ipv4>:5000/api/hello-world`

Now that we know the app is running successfully, we will create a service:


vim /etc/systemd/system/blog.service:
```
[Unit]
Description=Gunicorn instance to serve your Flask app
After=network.target

[Service]
User=root
Group=root
WorkingDirectory=/root/react-flask-custom-blog/backend
Environment="PATH=/root/blog-venv/bin"
ExecStart=/root/blog-venv/bin/gunicorn --workers 3 --bind 0.0.0.0:5000 -m 007 app:app

[Install]
WantedBy=multi-user.target
```

curl request to test: curl <ipv4>:5000/api/hello-world to make sure that the gunicorn service is running


sudo systemctl start blog.service
sudo systemctl enable blog.service
sudo systemctl status blog.service

after change to service file: systemctl daemon-reload
sudo systemctl restart blog.service

Errors associated with systemctl restart can be seen via cat /var/log/syslog

sudo journalctl -u nginx
sudo journalctl -u blog


## Reverse Proxy Set up

So we don't have to specify the port

## Continous Deployment Setup

1. Generate an SSH keypair on your droplet and add the public key to GitHub as a Deploy Key: `ssh-keygen -t ed25519 -C "your-email@example.com"`
	- Save the key to the default location of `~/.ssh/id_ed225519``
2. Add the public key (~/.ssh/id_ed25519.pub) to your Github repo: Repo > Settings > Deploy Keys > Add Deploy key (This allows your DigitalOcean droplet to access your GitHub repository via SSH)
3. Add the private key to your repo's Secrets as DD_SSH_PRIVATE_KEY so that Github Actions can use the private key (This allows GitHub Actions (running on GitHub's servers) to SSH into your DigitalOcean droplet to execute commands)
	- Repo > Settings > Secrets and variables > Actions > New Repository Secret
4. Add the DO droplet ipv4 address to the repo's Secret as `DO_DROPLET_IP`
	- Repo > Settings > Secrets and variables > Actions > New Repository Secret


Note: If there are any issues with ssh connection such as `root@1<ipv4>: Permission denied (publickey)``
- Check if the public key is added to authorized_keys: cat ~/.ssh/id_ed25519.pub
	- If the public key is not there:
		- `cat ~/.ssh/id_ed25519.pub >> ~/.ssh/authorized_keys`
- To check the ssh connection: `ssh -T git@github.com`
	- If successful, you will see a message like `Hi username! You've successfully authenticated, but GitHub does not provide shell access.`


## Docker Installation on Droplet

https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-20-04