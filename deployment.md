# Digital Ocean

1. Create new project
2. Manage > Droplets
3. Create Droplet
    - Region: New York
    - Datacenter: New York Data Center 1 NYC1
    - OS: Ubuntu
    - Version: 24.04 (LTS) x64
    - Size: Basic
    - CPU Options: Regular Disk type: ssd
    - $4 a month
    - Authentication method: SSH Key
        - Run ssh-keygen on local machine
        - This will generate two files, by default called id_rsa and id_rsa.pub. Next, add this public key.
        - Copy and paste the contents of the .pub file, typically id_rsa.pub, into the SSH key content field on the left.: cat ~/.ssh/id_rsa.pub
    - Quantity: 1 Droplet
    - Project: react-blog
    

ssh into digital ocean droplet

ssh root@<ipv4>

sudo apt update
sudo apt -y upgrade

sudo apt install nodejs npm

confirm:
    - node -v
    - npm -v

git clone https://github.com/loganphillips792/react-flask-custom-blog.git
cd react-flask-custom-blog/frontend/react-flask-custom-blog

npm install

npm run build - prepare app for production. This creates a build/ directory with the production-ready files


npm install -g serve

serve -s dist

Now you should be able to access at: ipv4@:3000


## Nginx - Reverse Proxy

so we don't have to include the port

sudo apt install nginx

sudo vim /etc/nginx/sites-available/default

```
##
# You should look at the following URL's in order to grasp a solid understanding
# of Nginx configuration files in order to fully unleash the power of Nginx.
# https://www.nginx.com/resources/wiki/start/
# https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/
# https://wiki.debian.org/Nginx/DirectoryStructure
#
# In most cases, administrators will remove this file from sites-enabled/ and
# leave it as reference inside of sites-available where it will continue to be
# updated by the nginx packaging team.
#
# This file will automatically load configuration files provided by other
# applications, such as Drupal or Wordpress. These applications will be made
# available underneath a path with that package name, such as /drupal8.
#
# Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.
##

# Default server configuration
#
server {
	listen 80 default_server;
	listen [::]:80 default_server;

	# SSL configuration
	#
	# listen 443 ssl default_server;
	# listen [::]:443 ssl default_server;
	#
	# Note: You should disable gzip for SSL traffic.
	# See: https://bugs.debian.org/773332
	#
	# Read up on ssl_ciphers to ensure a secure configuration.
	# See: https://bugs.debian.org/765782
	#
	# Self signed certs generated by the ssl-cert package
	# Don't use them in a production server!
	#
	# include snippets/snakeoil.conf;

	root /var/www/html;

	# Add index.php to the list if you are using PHP
	index index.html index.htm index.nginx-debian.html;

	server_name _;

	location / {
		# First attempt to serve request as file, then
		# as directory, then fall back to displaying a 404.
		try_files $uri $uri/ =404;
	}

	# pass PHP scripts to FastCGI server
	#
	#location ~ \.php$ {
	#	include snippets/fastcgi-php.conf;
	#
	#	# With php-fpm (or other unix sockets):
	#	fastcgi_pass unix:/run/php/php7.4-fpm.sock;
	#	# With php-cgi (or other tcp sockets):
	#	fastcgi_pass 127.0.0.1:9000;
	#}

	# deny access to .htaccess files, if Apache's document root
	# concurs with nginx's one
	#
	#location ~ /\.ht {
	#	deny all;
	#}
}


# Virtual Host configuration for example.com
#
# You can move that to a different file under sites-available/ and symlink that
# to sites-enabled/ to enable it.
#
#server {
#	listen 80;
#	listen [::]:80;
#
#	server_name example.com;
#
#	root /var/www/example.com;
#	index index.html;
#
#	location / {
#		try_files $uri $uri/ =404;
#	}
#}


server {
    listen 80;
    server_name <ipv4_of_droplet>;

    location / {
        proxy_pass http://localhost:3000;  # Assuming serve runs on port 3000
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}

```

sudo systemctl restart nginx


Run serve -s dist and now you should be able to access at ipv4@:80 instead of ipv4@:3000


## SSL Certificate Setup








## PM2

Now we will use PM2 to run serve -s dist as a background process


npm install -g pm2


pm2 start serve --name "react-app" -- -s dist

pm2 startup - Ensure the process starts on reboot: To make sure the app starts when the server reboots, you need to set up pm2 to run at startup

pm2 save - Save the process list: After setting up the startup script, save the current running processes to be restored automatically on reboot


- pm2 list - check running apps
- pm2 logs react-app - view logs
- pm2 stop react-app
- pm2 restart react-app
- pm2 delete react-app

## systemd service

Alternatively, you can create a systemd service to run serve -s build as a background process. This method is more integrated with Linux systems and also ensures that the process runs on system boot.



1. Create a new systemd service file: Create a service file for your app by running: sudo nano /etc/systemd/system/react-app.service


2. Define the service configuration: Paste the following configuration into the file:

```
[Unit]
Description=React App
After=network.target

[Service]
ExecStart=/usr/bin/serve -s /path/to/your/react/app/build
Restart=always
User=root
Environment=PATH=/usr/bin:/usr/local/bin
Environment=NODE_ENV=production
WorkingDirectory=/path/to/your/react/app

[Install]
WantedBy=multi-user.target
```

3. sudo systemctl daemon-reload

4. sudo systemctl start react-app

5. sudo systemctl enable react-app

6. sudo systemctl status react-app

7. journalctl -u react-app -f

## Nginx - serve static files

Using Nginx as a web server

```
##
# You should look at the following URL's in order to grasp a solid understanding
# of Nginx configuration files in order to fully unleash the power of Nginx.
# https://www.nginx.com/resources/wiki/start/
# https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/
# https://wiki.debian.org/Nginx/DirectoryStructure
#
# In most cases, administrators will remove this file from sites-enabled/ and
# leave it as reference inside of sites-available where it will continue to be
# updated by the nginx packaging team.
#
# This file will automatically load configuration files provided by other
# applications, such as Drupal or Wordpress. These applications will be made
# available underneath a path with that package name, such as /drupal8.
#
# Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.
##

# Default server configuration
#
server {
	listen 80 default_server;
	listen [::]:80 default_server;

	# SSL configuration
	#
	# listen 443 ssl default_server;
	# listen [::]:443 ssl default_server;
	#
	# Note: You should disable gzip for SSL traffic.
	# See: https://bugs.debian.org/773332
	#
	# Read up on ssl_ciphers to ensure a secure configuration.
	# See: https://bugs.debian.org/765782
	#
	# Self signed certs generated by the ssl-cert package
	# Don't use them in a production server!
	#
	# include snippets/snakeoil.conf;

	root /var/www/html;

	# Add index.php to the list if you are using PHP
	index index.html index.htm index.nginx-debian.html;

	server_name _;

	location / {
		# First attempt to serve request as file, then
		# as directory, then fall back to displaying a 404.
		try_files $uri $uri/ =404;
	}

	# pass PHP scripts to FastCGI server
	#
	#location ~ \.php$ {
	#	include snippets/fastcgi-php.conf;
	#
	#	# With php-fpm (or other unix sockets):
	#	fastcgi_pass unix:/run/php/php7.4-fpm.sock;
	#	# With php-cgi (or other tcp sockets):
	#	fastcgi_pass 127.0.0.1:9000;
	#}

	# deny access to .htaccess files, if Apache's document root
	# concurs with nginx's one
	#
	#location ~ /\.ht {
	#	deny all;
	#}
}


# Virtual Host configuration for example.com
#
# You can move that to a different file under sites-available/ and symlink that
# to sites-enabled/ to enable it.
#
#server {
#	listen 80;
#	listen [::]:80;
#
#	server_name example.com;
#
#	root /var/www/example.com;
#	index index.html;
#
#	location / {
#		try_files $uri $uri/ =404;
#	}
#}

server {
    listen 80;
    server_name 157.230.5.245;

    # Serve the React app from the build folder
    root /var/www/react-app/;
    index index.html;

    # Main location block for the React app
    location / {
        try_files $uri /index.html;
    }
}
```

if you go to ipv4:80, you will see the Nginx set up page

Can now access files like http://157.230.5.245/vite.svg



## Netlify


Base directory: frontend/react-flask-custom-blog
Package directory: not set
Build command: npm run build
publish directory: frontend/react-flask-custom-blog/dist

# Flask Setup

SSH into digital ocean droplet: `ssh root@<ipv4_of_droplet>`

cat /var/log/nginx/access.log
cat /var/log/nginx/error.log


1. sudo apt update
2. sudo apt -y upgrade
3. apt install python3.12-venv
4. cd ~
5. sudo python3 -m venv blog-venv
6. source ~/blog-venv/bin/activate
7. which pip
8. ~/blog-venv/bin/python3 -m pip install --upgrade pip
9. pip install -r react-flask-custom-blog/backend/requirements.txt
10. cp .env.example .env
11. python app.py to make sure there aren't any errors


cd ~/react-flask-custom-blog/backend

gunicorn --workers 3 --bind 0.0.0.0:5000 -m 007 app:app

curl request to test: `curl <ipv4>:5000/api/hello-world`

Now that we know the app is running successfully, we will create a service:


vim /etc/systemd/system/blog.service:
```
[Unit]
Description=Gunicorn instance to serve your Flask app
After=network.target

[Service]
User=root
Group=root
WorkingDirectory=/root/react-flask-custom-blog/backend
Environment="PATH=/root/blog-venv/bin"
ExecStart=/root/blog-venv/bin/gunicorn --workers 3 --bind 0.0.0.0:5000 -m 007 app:app

[Install]
WantedBy=multi-user.target
```

curl request to test: curl <ipv4>:5000/api/hello-world to make sure that the gunicorn service is running


sudo systemctl start blog.service
sudo systemctl enable blog.service
sudo systemctl status blog.service

after change to service file: systemctl daemon-reload
sudo systemctl restart blog.service

Errors associated with systemctl restart can be seen via cat /var/log/syslog

sudo journalctl -u nginx
sudo journalctl -u blog


## Reverse Proxy Set up

So we don't have to specify the port

## Continous Deployment Setup

1. Generate an SSH keypair on your droplet and add the public key to GitHub as a Deploy Key: `ssh-keygen -t ed25519 -C "your-email@example.com"`
	- Save the key to the default location of `~/.ssh/id_ed225519``
2. Add the public key (~/.ssh/id_ed25519.pub) to your Github repo: Repo > Settings > Deploy Keys > Add Deploy key (This allows your DigitalOcean droplet to access your GitHub repository via SSH)
3. Add the private key to your repo's Secrets as DD_SSH_PRIVATE_KEY so that Github Actions can use the private key (This allows GitHub Actions (running on GitHub's servers) to SSH into your DigitalOcean droplet to execute commands)
	- Repo > Settings > Secrets and variables > Actions > New Repository Secret
4. Add the DO droplet ipv4 address to the repo's Secret as `DO_DROPLET_IP`
	- Repo > Settings > Secrets and variables > Actions > New Repository Secret

## Docker Installation on Droplet

https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-20-04